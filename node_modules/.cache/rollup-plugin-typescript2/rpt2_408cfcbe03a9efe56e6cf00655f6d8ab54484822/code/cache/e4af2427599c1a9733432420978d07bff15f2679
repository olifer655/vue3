{"code":"// runtime-core  根平台无关的运行时  \r\nimport { ReactiveEffect } from '@vue/reactivity';\r\nimport { createAppAPI } from './apiCreateApp';\r\nimport { createComponentInstance, setupComponent } from './component';\r\nimport { isSameVNodeType, normalizeVNode, Text } from './createVNode';\r\nexport function createRenderer(renderOptions) {\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, } = renderOptions;\r\n    const setupRenderEffect = (initialVNode, instance, container) => {\r\n        // 创建渲染effect\r\n        // 核心就是调用render，数据变化 就重新调用render \r\n        const componentUpdateFn = () => {\r\n            let { proxy } = instance; //  render中的参数\r\n            if (!instance.isMounted) {\r\n                // 组件初始化的流程\r\n                // 调用render方法 （渲染页面的时候会进行取值操作，那么取值的时候会进行依赖收集 ， 收集对应的effect，稍后属性变化了会重新执行当前方法）\r\n                const subTree = instance.subTree = instance.render.call(proxy, proxy); // 渲染的时候会调用h方法\r\n                // 真正渲染组件 其实渲染的应该是subTree\r\n                patch(null, subTree, container); // 稍后渲染完subTree 会生成真实节点之后挂载到subTree\r\n                initialVNode.el = subTree.el;\r\n                instance.isMounted = true;\r\n            }\r\n            else {\r\n                // 组件更新的流程 。。。\r\n                // 我可以做 diff算法   比较前后的两颗树 \r\n                const prevTree = instance.subTree;\r\n                const nextTree = instance.render.call(proxy, proxy);\r\n                patch(prevTree, nextTree, container); // 比较两棵树\r\n            }\r\n        };\r\n        const effect = new ReactiveEffect(componentUpdateFn);\r\n        // 默认调用update方法 就会执行componentUpdateFn\r\n        const update = effect.run.bind(effect);\r\n        update();\r\n    };\r\n    const mountComponent = (initialVNode, container) => {\r\n        // 根据组件的虚拟节点 创造一个真实节点 ， 渲染到容器中\r\n        // 1.我们要给组件创造一个组件的实例 \r\n        const instance = initialVNode.component = createComponentInstance(initialVNode);\r\n        // 2. 需要给组件的实例进行赋值操作\r\n        setupComponent(instance); // 给实例赋予属性\r\n        // 3.调用render方法实现 组件的渲染逻辑。 如果依赖的状态发生变化 组件要重新渲染\r\n        // 数据和视图是双向绑定的 如果数据变化视图要更新 响应式原理 \r\n        // effect  data  effect 可以用在组件中，这样数据变化后可以自动重新的执行effect函数\r\n        setupRenderEffect(initialVNode, instance, container); // 渲染effect\r\n    };\r\n    const processComponent = (n1, n2, container) => {\r\n        if (n1 == null) {\r\n            // 组件的初始化\r\n            mountComponent(n2, container);\r\n        }\r\n        else {\r\n            // 组件的更新\r\n        }\r\n    };\r\n    const mountChildren = (children, container) => {\r\n        // 如果是一个文本 可以直接   el.textContnt = 文本2\r\n        // ['文本1','文本2']   两个文本 需要 创建两个文本节点 塞入到我们的元素中\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = (children[i] = normalizeVNode(children[i]));\r\n            patch(null, child, container); // 如果是文本需要特殊处理\r\n        }\r\n    };\r\n    const mountElement = (vnode, container) => {\r\n        // vnode中的children  可能是字符串 或者是数组  对象数组  字符串数组\r\n        let { type, props, shapeFlag, children } = vnode; // 获取节点的类型 属性 儿子的形状 children\r\n        let el = vnode.el = hostCreateElement(type);\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            hostSetElementText(el, children);\r\n        }\r\n        else if (shapeFlag & 16 /* ARRAY_CHILDREN */) { // 按位与\r\n            mountChildren(children, el);\r\n        }\r\n        // 处理属性\r\n        if (props) {\r\n            for (const key in props) {\r\n                hostPatchProp(el, key, null, props[key]); // 给元素添加属性\r\n            }\r\n        }\r\n        hostInsert(el, container);\r\n    };\r\n    const patchProps = (oldProps, newProps, el) => {\r\n        if (oldProps === newProps)\r\n            return;\r\n        for (let key in newProps) {\r\n            const prev = oldProps[key];\r\n            const next = newProps[key]; // 获取新老属性\r\n            if (prev !== next) {\r\n                hostPatchProp(el, key, prev, next);\r\n            }\r\n        }\r\n        for (const key in oldProps) { // 老的有新的没有  移除老的\r\n            if (!(key in newProps)) {\r\n                hostPatchProp(el, key, oldProps[key], null);\r\n            }\r\n        }\r\n    };\r\n    const patchElement = (n1, n2) => {\r\n        let el = n2.el = n1.el; // 先比较元素 元素一致 则复用 \r\n        const oldProps = n1.props || {}; // 复用后比较属性\r\n        const newProps = n2.props || {};\r\n        patchProps(oldProps, newProps, el);\r\n        // 实现比较儿子  diff算法  \r\n    };\r\n    const processElement = (n1, n2, container) => {\r\n        if (n1 == null) {\r\n            // 初始化\r\n            mountElement(n2, container);\r\n        }\r\n        else {\r\n            // diff\r\n            patchElement(n1, n2); // 更新两个元素之间的差异\r\n        }\r\n    };\r\n    const processText = (n1, n2, container) => {\r\n        if (n1 === null) {\r\n            // 文本的初始化 \r\n            let textNode = hostCreateText(n2.children);\r\n            hostInsert(textNode, container);\r\n        }\r\n    };\r\n    const unmount = (vnode) => {\r\n        hostRemove(vnode.el); // 删除真实节点即可\r\n    };\r\n    const patch = (n1, n2, container) => {\r\n        // 两个元素 完全没用关系 \r\n        if (n1 && !isSameVNodeType(n1, n2)) { // n1 有值 再看两个是否是相同节点\r\n            unmount(n1);\r\n            n1 = null;\r\n        }\r\n        // 如果前后元素不一致 需要删除老的元素 换成新的元素\r\n        if (n1 == n2)\r\n            return;\r\n        const { shapeFlag, type } = n2; // createApp(组件)\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container);\r\n                }\r\n                else if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container);\r\n                }\r\n        }\r\n    };\r\n    const render = (vnode, container) => {\r\n        // 后续还有更新 patch  包含初次渲染 还包含更新\r\n        patch(null, vnode, container); // 后续更新 prevNode nextNode container\r\n    };\r\n    // \r\n    return {\r\n        createApp: createAppAPI(render),\r\n        render\r\n    };\r\n}\r\n//# sourceMappingURL=rendener.js.map","references":["C:/Users/test1/Desktop/vue-topic/vue-train-5/packages/shared/src/index.ts","C:/Users/test1/Desktop/vue-topic/vue-train-5/packages/reactivity/src/index.ts","C:/Users/test1/Desktop/vue-topic/vue-train-5/packages/runtime-core/src/apiCreateApp.ts","C:/Users/test1/Desktop/vue-topic/vue-train-5/packages/runtime-core/src/component.ts","C:/Users/test1/Desktop/vue-topic/vue-train-5/packages/runtime-core/src/createVNode.ts"],"map":"{\"version\":3,\"file\":\"rendener.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/runtime-core/src/rendener.ts\"],\"names\":[],\"mappings\":\"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\"}"}
