{"version":3,"file":"runtime-dom.global.js","sources":["../../shared/src/index.ts","../../runtime-core/src/createVNode.ts","../../runtime-core/src/h.ts","../../reactivity/src/effect.ts","../../reactivity/src/reactive.ts","../../reactivity/src/computed.ts","../../reactivity/src/ref.ts","../../runtime-core/src/apiCreateApp.ts","../../runtime-core/src/component.ts","../../runtime-core/src/rendener.ts","../src/nodeOps.ts","../src/patchProp.ts","../src/index.ts"],"sourcesContent":["export function isObject(value: unknown): value is Record<any, any> {\r\n  return typeof value === 'object' && value !== null\r\n}\r\n\r\nexport function isFunction(value): boolean {\r\n  return typeof value === 'function'\r\n}\r\nexport function isString(value) {\r\n  return typeof value === 'string'\r\n}\r\n\r\nexport const enum ShapeFlags {\r\n  ELEMENT = 1, // 元素\r\n  FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件\r\n  STATEFUL_COMPONENT = 1 << 2, // 普通组件\r\n  TEXT_CHILDREN = 1 << 3, // 孩子是文本\r\n  ARRAY_CHILDREN = 1 << 4, // 孩子是数组\r\n  SLOTS_CHILDREN = 1 << 5, // 组件插槽\r\n  TELEPORT = 1 << 6, // teleport组件\r\n  SUSPENSE = 1 << 7, // suspense组件\r\n  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT \t// 组件\r\n}\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty\r\nexport const hasOwn = (value,key) => hasOwnProperty.call(value,key);\r\n/*\r\nlet r = ShapeFlags.ELEMENT | ShapeFlags.FUNCTIONAL_COMPONENT; // r包含元素和函数式组件\r\n// 我们像看r 是不是元素\r\n(r & ShapeFlags.ELEMENT) > 0; // 说明包含元素\r\n(r & ShapeFlags.FUNCTIONAL_COMPONENT) > 0\r\n*/\r\n\r\n\r\n  // 二进制  00000100  位移  | & 是做权限必备的一个操作 \r\n  // | 来组合权限 & 来判断是否包含某个权限\r\n//   001 |  010 => 011  =3    011 & 001 = 001   011 & 010 => 010   011 & 100  -> 000\r\n  // 001\r\n  // 010\r\n  // 100","import { isObject, isString, ShapeFlags } from \"@vue/shared\";\r\nexport function createVNode(type, props, children = null) { // h('div',{},['helloolifer','helloolifer'])\r\n\r\n    // 虚拟节点就是 用一个对象来描述信息的  \r\n\r\n    // & | \r\n    const shapeFlag = isObject(type) ?\r\n        ShapeFlags.COMPONENT :\r\n        isString(type) ?\r\n            ShapeFlags.ELEMENT :\r\n            0\r\n\r\n    const vnode = { // 跨平台\r\n        __v_isVNode: true,\r\n        type,\r\n        shapeFlag,\r\n        props,\r\n        children,\r\n        key: props && props.key, // key值\r\n        component: null, // 如果是组件的虚拟节点要保存组件的实例\r\n        el: null, // 虚拟节点对应的真实节点\r\n    }\r\n    if(children){\r\n        // 告诉此节点 是什么样的儿子 \r\n        // 稍后渲染虚拟节点的时候 可以判断儿子是数组 就循环渲染\r\n        vnode.shapeFlag =  vnode.shapeFlag | (isString(children) ? ShapeFlags.TEXT_CHILDREN:ShapeFlags.ARRAY_CHILDREN)\r\n    }\r\n    // vnode 就可以描述出来 当前他是一个什么样的节点 儿子是什么样的\r\n    return vnode; // createApp(App)\r\n}\r\nexport function isVNode(vnode){\r\n    return !!vnode.__v_isVNode\r\n}\r\n\r\nexport const Text = Symbol();\r\nexport function normalizeVNode(vnode){\r\n    if(isObject(vnode)){\r\n        return vnode;\r\n    }\r\n    return createVNode(Text,null,String(vnode));\r\n}\r\n\r\nexport function isSameVNodeType(n1,n2){\r\n    // 比较类型是否一致 比较key是否一致\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}","import { isObject } from \"@vue/shared\";\r\nimport { isVNode, createVNode } from \"./createVNode\";\r\n\r\nexport function h(type, propsOrChildren, children) {\r\n    // 写法1.  h('div',{color:red})\r\n    // 写法2.  h('div',h('span'))\r\n    // 写法3   h('div','hello')\r\n    // 写法4：  h('div',['hello','hello'])\r\n    let l = arguments.length;\r\n    if (l === 2) {\r\n        if (isObject(propsOrChildren) && !Array.isArray(propsOrChildren)) {\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren])//  h('div',h('span'))\r\n            }\r\n            return createVNode(type, propsOrChildren);  //  h('div',{color:red})\r\n        } else {\r\n            return createVNode(type, null, propsOrChildren); // h('div','hello')   h('div',['hello','hello'])\r\n        }\r\n    } else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        } else if (l === 3 && isVNode(children)) {\r\n            children = [children]\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n    // h('div',{},'孩子')\r\n    // h('div',{},['孩子','孩子','孩子'])\r\n    // h('div',{},[h('span'),h('span'),h('span')])\r\n}","// effect1(()=>{\r\n//     state.name\r\n//     effect2(()=>{\r\n//         state.age;\r\n//     })\r\n//     state.address\r\n// })\r\n\r\n// // effectStack = [effect1] activeEffect = effect1\r\n// // effect1 -> name\r\n// // effect2 -> age\r\n// // effect1 -> address\r\n\r\n\r\nlet effectStack = []; // 目的就是为了能保证我们effect执行的时候 可以存储正确的关系\r\nlet activeEffect;\r\n\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    for (let dep of deps) {\r\n        // set 删除effect 让属性 删除掉对应的effect   name = []\r\n        dep.delete(effect); // 让属性对应的effect移除掉，这样属性更新的时候 就不会触发这个effect重新执行了\r\n    }\r\n}\r\n// 属性变化 触发的是 dep -> effect\r\n// effect.deps = [] 和属性是没关系的\r\nexport class ReactiveEffect {\r\n    active = true; // this.active = true;\r\n    deps = []; // 让effect 记录他依赖了哪些属性 ， 同时要记录当前属性依赖了哪个effect\r\n    constructor(public fn, public scheduler?) { // this.fn = fn;\r\n\r\n    }\r\n    run() { // 调用run的时候会让fn执行\r\n        if (!this.active) { // 稍后如果非激活状态 调用run方法 默认会执行fn函数\r\n            return this.fn();\r\n        }\r\n        if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行\r\n            try {\r\n                effectStack.push(activeEffect = this);\r\n                return this.fn(); // 取值  new Proxy 会执行get方法  (依赖收集)\r\n            } finally {\r\n                effectStack.pop(); // 删除最后一个\r\n                activeEffect = effectStack[effectStack.length - 1]\r\n            }\r\n        }\r\n    }\r\n    stop() { // 让effect 和 dep 取消关联 dep上面存储的effect移除掉即可\r\n        if (this.active) {\r\n            cleanupEffect(this)\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\n// obj name :[effect]\r\n//     age : [effect]\r\n// {对象：{属性 ： [effect,effect]}  } \r\nexport function isTracking() {\r\n    return activeEffect !== undefined\r\n}\r\nconst targetMap = new WeakMap();\r\nexport function track(target, key) { // 一个属性对应多个effect， 一个effect中依赖了多个属性 =》 多对多\r\n    // 是只要取值我就要收集吗？\r\n    if (!isTracking()) { // 如果这个属性 不依赖于effect直接跳出即可\r\n        return\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map())); // {对象：map{}}\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));// {对象：map{name:set[]}}\r\n    }\r\n    trackEffects(dep);\r\n\r\n}\r\nexport function trackEffects(dep) {\r\n    let shouldTrack = !dep.has(activeEffect); // 看一下这个属性有没有存过这个effect\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect); // // {对象：map{name:set[effect,effect]}}\r\n        activeEffect.deps.push(dep); // 稍后用到\r\n    } // { 对象：{name:set,age:set}\r\n\r\n}\r\nexport function trigger(target, key) {\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) return;// 属性修改的属性 根本没有依赖任何的effect\r\n    let deps = []; // [set ,set ]\r\n    if (key !== undefined) {\r\n        deps.push(depsMap.get(key));\r\n    }\r\n    let effects = [];\r\n    for (const dep of deps) {\r\n        effects.push(...dep)\r\n    }\r\n    triggerEffects(effects);\r\n}\r\nexport function triggerEffects(dep) {\r\n    for (const effect of dep) { // 如果当前effect执行 和 要执行的effect是同一个，不要执行了 防止循环\r\n        if (effect !== activeEffect) {\r\n            if (effect.scheduler) {\r\n                return effect.scheduler()\r\n            }\r\n            effect.run(); // 执行effect\r\n        }\r\n    }\r\n}\r\nexport function effect(fn) {\r\n    const _effect = new ReactiveEffect(fn);\r\n    _effect.run(); // 会默认让fn执行一次\r\n    let runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect; // 给runner添加一个effect实现 就是 effect实例\r\n    return runner;\r\n}\r\n\r\n// vue3 的响应式原理  取值时 收集对应的effect， 改值时找到对应的effect执行","import { isObject } from \"@vue/shared\"\r\nimport { track, trigger } from \"./effect\";\r\n\r\n\r\nconst enum ReactiveFlags {\r\n    IS_REACTIVE = '__v_isReactive'\r\n}\r\nconst mutableHandlers: ProxyHandler<Record<any, any>> = {\r\n    get(target, key, recevier) { // 代理对象的本身\r\n        if (key === ReactiveFlags.IS_REACTIVE) {\r\n            return true;\r\n        }\r\n        track(target,key);\r\n        // 这里取值了， 可以收集他在哪个effect中\r\n        const res = Reflect.get(target, key, recevier); // target[key]\r\n        return res;\r\n    },\r\n    set(target, key, value, recevier) {\r\n\r\n        let oldValue = (target as any)[key]\r\n        // 如果改变值了， 可以在这里触发effect更新\r\n        const res = Reflect.set(target, key, value, recevier); // target[key] = value\r\n\r\n        if(oldValue !== value){ // 值不发生变化 effect不需要重新执行\r\n            trigger(target,key); // 找属性对应的effect让她重新执行\r\n        }\r\n        return res;\r\n    }\r\n}\r\n// map和weakMap的区别\r\nconst reactiveMap = new WeakMap(); // weakmap 弱引用   key必须是对象，如果key没有被引用可以被自动销毁\r\n\r\nfunction createReactiveObject(target: object) { \r\n    // 先默认认为这个target已经是代理过的属性了\r\n    if ((target as any)[ReactiveFlags.IS_REACTIVE]) {\r\n        return target\r\n    }\r\n    // reactiveApi 只针对对象才可以 \r\n    if (!isObject(target)) {\r\n        return target\r\n    }\r\n    const exisitingProxy = reactiveMap.get(target); // 如果缓存中有 直接使用上次代理的结果\r\n    if (exisitingProxy) {\r\n        return exisitingProxy\r\n    }\r\n    const proxy = new Proxy(target, mutableHandlers); // 当用户获取属性 或者更改属性的时候 我能劫持到\r\n    reactiveMap.set(target, proxy); // 将原对象和生成的代理对象 做一个映射表\r\n\r\n    return proxy; // 返回代理\r\n}\r\n\r\nexport function reactive(target: object) {\r\n    return createReactiveObject(target)\r\n}\r\nexport function toReactive(value){\r\n    return isObject(value) ? reactive(value) : value\r\n}\r\n\r\n// readonly shallowReactive shallowReadnly \r\n// export function readonly(){\r\n// }\r\n// export function shallowReactive(){\r\n// }\r\n// export function shallowReadnly(){\r\n// }\r\n","import { isFunction } from \"@vue/shared\";\r\nimport { isTracking, ReactiveEffect, trackEffects, triggerEffects } from \"./effect\";\r\n\r\n\r\nclass ComputedRefImpl {\r\n    public dep; // this.dep = undefined;\r\n    public _dirty = true; // this._dirty = true;\r\n    public __v_isRef = true;\r\n    public effect; // 计算属性是依赖于effect的\r\n    public _value;\r\n    constructor(getter, public setter) { // 只有调用computed()才执行一次\r\n        // 这里将计算属性包成一个effect\r\n        // 这里 我给计算属性变成了effect ，那么计算属性中的属性会收集这个effect\r\n        this.effect = new ReactiveEffect(getter,()=>{\r\n            // 稍后计算属性依赖的值变化 不要重新执行计算属性的effect，而是调用此函数\r\n            if(!this._dirty){\r\n                this._dirty = true;\r\n                triggerEffects(this.dep )\r\n            }\r\n        });\r\n    }\r\n    get value() { // 取值时会走get方法\r\n        if (isTracking()) { // 是否是在effect中取值的\r\n            trackEffects(this.dep || (this.dep = new Set))\r\n        }\r\n        if (this._dirty) {\r\n            // 将结果缓存到this._value 这样就不用每次都run了\r\n            this._value = this.effect.run();\r\n            this._dirty = false;\r\n        }\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this.setter(newValue); // 如果修改计算属性的值 就触发你自己的set方法\r\n    }\r\n}\r\nexport function computed(getterOrOptions) {\r\n    const onlyGetter = isFunction(getterOrOptions);\r\n    let getter;\r\n    let setter;\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = () => { }\r\n    } else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n\r\n    return new ComputedRefImpl(getter, setter)\r\n}","import { isTracking, trackEffects, triggerEffects } from \"./effect\";\r\nimport { toReactive } from \"./reactive\";\r\n\r\nclass RefImpl{\r\n    public dep;\r\n    public __v_isRef;\r\n    public _value;\r\n    constructor(public _rawValue){ // 原来的值\r\n        // _rawValue如果用户传进来的值 是一个对象 我需要将对象转化成响应式\r\n        this._value = toReactive(_rawValue)\r\n    }\r\n\r\n  \r\n    // 类的属性访问器 最终会变成deifneProperty\r\n    get value(){ // 取值的时候进行依赖收集\r\n        if(isTracking()){\r\n            trackEffects(this.dep || (this.dep = new Set()));\r\n        }\r\n        return this._value;\r\n    }\r\n    set value(newValue){ // 设置的时候触发更新\r\n        if(newValue !== this._rawValue){\r\n            // 先看一下之前之后是否一样\r\n            this._rawValue = newValue;\r\n            this._value =  toReactive(newValue);\r\n            triggerEffects(this.dep);\r\n        }\r\n    }\r\n}\r\n\r\nfunction createRef(value){\r\n\r\n    return new RefImpl(value);\r\n}\r\n\r\n\r\nexport function ref(value){\r\n    return createRef(value);\r\n}\r\n\r\n// export function shallowRef(value){\r\n //   return createRef(value,true);\r\n// }\r\n\r\n// reactive readonly ","import { createVNode } from \"./createVNode\";\r\n\r\nexport function createAppAPI(render) {\r\n    return (rootComponent, rootProps) => {\r\n        let isMounted = false;\r\n        const app = {\r\n            mount(container) {\r\n                // 1.创造组件虚拟节点 \r\n                let vnode = createVNode(rootComponent, rootProps); // h函数\r\n                // 2.挂载的核心就是根据传入的组件对象 创造一个组件的虚拟节点 ，在将这个虚拟节点渲染到容器中\r\n                render(vnode, container)\r\n                if (!isMounted) {\r\n                    isMounted = true;\r\n                }\r\n            }\r\n        }\r\n        return app\r\n    }\r\n}\r\n","import { reactive } from '@vue/reactivity';\r\nimport { hasOwn, isFunction, isObject } from '@vue/shared';\r\nexport function createComponentInstance(vnode){\r\n    const type = vnode.type; // 用户自己传入的属性\r\n    const instance = {\r\n        vnode, // 实例对应的虚拟节点\r\n        type, // 组件对象\r\n        subTree: null, // 组件渲染的内容   vue3中组件的vnode 就叫vnode  组件渲染的结果 subTree\r\n        ctx: {}, // 组件上下文\r\n        props: {}, // 组件属性\r\n        attrs: {}, // 除了props中的属性 \r\n        slots: {}, // 组件的插槽\r\n        setupState: {}, // setup返回的状态\r\n        propsOptions: type.props, // 属性选项\r\n        proxy: null, // 实例的代理对象\r\n        render:null, // 组件的渲染函数\r\n        emit: null, // 事件触发\r\n        exposed:{}, // 暴露的方法\r\n        isMounted: false // 是否挂载完成\r\n    }\r\n    instance.ctx = {_:instance}; // 稍后会说 ， 后续会对他进行代理\r\n    return instance;\r\n}\r\nexport function initProps(instance,rawProps){\r\n    const props = {};\r\n    const attrs = {};\r\n    const options = Object.keys(instance.propsOptions); // 用户注册过的, 校验类型\r\n    if(rawProps){\r\n        for(let key in rawProps){\r\n            const value = rawProps[key];\r\n            if(options.includes(key)){\r\n                props[key] = value;\r\n            }else{\r\n                attrs[key] = value\r\n            }\r\n        }\r\n    }\r\n    instance.props = reactive(props);\r\n    instance.attrs = attrs; // 这个attrs 是非响应式的\r\n}\r\n\r\nfunction createSetupContext(instance){\r\n    return {\r\n        attrs:instance.attrs,\r\n        slots:instance.slots,\r\n        emit:instance.emit,\r\n        expose:(exposed) =>instance.exposed = exposed || {}\r\n    }\r\n}\r\nconst PublicInstanceProxyHandlers = {\r\n    get({_:instance},key){\r\n        const {setupState,props} = instance;  // 同名 props 和状态同名   通过proxy 可以直接访问状态和属性\r\n        if(hasOwn(setupState,key)){\r\n            return setupState[key];\r\n        }else if(hasOwn(props,key)){\r\n            return props[key];\r\n        }else{\r\n            // ....\r\n        }\r\n    },\r\n    set({_:instance},key,value){\r\n        const {setupState,props} = instance; // 属性不能修改\r\n        if(hasOwn(setupState,key)){\r\n             setupState[key] = value;\r\n        }else if(hasOwn(props,key)){\r\n            console.warn('Props are readonly')\r\n            return false;\r\n        }else{\r\n            // ....\r\n        }\r\n        return true\r\n    }\r\n}\r\nexport function setupStatefulComponent(instance){\r\n    // 核心就是调用组件的setup方法\r\n    const Component = instance.type;\r\n    const {setup} = Component;\r\n    instance.proxy = new Proxy(instance.ctx,PublicInstanceProxyHandlers); // proxy就是代理的上下文\r\n    if(setup){\r\n        const setupContext = createSetupContext(instance);\r\n        let setupResult = setup(instance.props,setupContext); /// 获取setup的返回值\r\n        if(isFunction(setupResult)){\r\n            instance.render = setupResult; // 如果setup返回的是函数那么就是render函数\r\n        }else if(isObject(setupResult)){\r\n            instance.setupState = setupResult;\r\n        }\r\n    }\r\n    if(!instance.render){\r\n        // 如果 没有render 而写的是template  可能要做模板编译  下个阶段 会实现如何将template -》 render函数 (耗性能)\r\n        instance.render = Component.render; // 如果setup没有写render 那么就采用组件本身的render\r\n    }\r\n}\r\n\r\nexport function setupComponent(instance){\r\n    const  {props,children} = instance.vnode;\r\n    // 组件的props 做初始化  attrs也要初始化\r\n    initProps(instance,props)\r\n    // 插槽的初始化\r\n    // initSlots(instance,children) ...\r\n    setupStatefulComponent(instance); // 这个方法的目的就是调用setup函数 拿到返回值 给\r\n\r\n}","\r\n// runtime-core  根平台无关的运行时  \r\n\r\nimport { ShapeFlags } from '@vue/shared'\r\nimport { ReactiveEffect } from '@vue/reactivity';\r\nimport { createAppAPI } from './apiCreateApp'\r\nimport { createComponentInstance, setupComponent } from './component';\r\nimport { isSameVNodeType, normalizeVNode, Text } from './createVNode';\r\nfunction getSequence(arr) {\r\n    let len = arr.length;\r\n    const result = [0]; // 这里放的是索引\r\n    let p = arr.slice(0); // 用来记录前驱节点的索引， 用来追溯正确的顺序\r\n    let lastIndex;\r\n    let start;\r\n    let end;\r\n    let middle;\r\n    // 1.直接看元素 如果比当前的末尾大直接追加即可  ok 1\r\n    for (let i = 0; i < len; i++) {\r\n        const arrI = arr[i]; // 存的每一项的值\r\n        if (arrI !== 0) {\r\n            lastIndex = result[result.length - 1]; // 获取结果集中的最后一个\r\n            if (arr[lastIndex] < arrI) { // 当前结果集中的最后一个 和这一项比较\r\n\r\n                // 记录当前前一个人索引\r\n                p[i] = lastIndex;\r\n                result.push(i);\r\n                continue\r\n            }\r\n            // 二分查找 替换元素 \r\n            start = 0;\r\n            end = result.length - 1;\r\n            while (start < end) { // start = end    0  3 = 1.5  二分查找\r\n                middle = ((start + end) / 2) | 0; // 中间的索引 \r\n                // 找到序列中间的索引， 通过索引找到对应的值\r\n                if (arr[result[middle]] < arrI) {\r\n                    start = middle + 1;\r\n                } else {\r\n                    end = middle;\r\n                }\r\n            }\r\n            if (arrI < arr[result[start]]) { // 要替换成 5的索引\r\n\r\n                // 这里在替换之前 应该让当前元素\r\n                p[i] = result[start - 1]; // 用找到的索引 标记到p上\r\n\r\n                result[start] = i;\r\n            } // 找到更有潜力 替换之前的 （贪心算法 ）\r\n        }\r\n    }\r\n    let i = result.length; // 拿到最后一个 开始向前追溯\r\n    let last = result[i - 1]; // 取出最后一个\r\n\r\n    while (i-- > 0) { // 通过前驱节点找到正确的调用顺序\r\n        result[i] = last; // 最后一项肯定是正确的\r\n        last = p[last]; // 通过最后一项 向前查找\r\n    }\r\n    return result;\r\n    // [0,1,2,3]   [2,3,8,9]  // 用5找到  递增的序列为了快速查找我们可以采用二分查找的方式进行查找  O（n）  O(logn)\r\n}\r\nexport function createRenderer(renderOptions) { // runtime-core   renderOptionsDOMAPI -> rootComponent -> rootProps -> container\r\n    const {\r\n        insert: hostInsert,\r\n        remove: hostRemove,\r\n        patchProp: hostPatchProp,\r\n        createElement: hostCreateElement,\r\n        createText: hostCreateText,\r\n        createComment: hostCreateComment,\r\n        setText: hostSetText,\r\n        setElementText: hostSetElementText,\r\n        parentNode: hostParentNode,\r\n        nextSibling: hostNextSibling,\r\n    } = renderOptions;\r\n\r\n\r\n    const setupRenderEffect = (initialVNode, instance, container) => {\r\n        // 创建渲染effect\r\n\r\n        // 核心就是调用render，数据变化 就重新调用render \r\n        const componentUpdateFn = () => {\r\n            let { proxy } = instance; //  render中的参数\r\n            if (!instance.isMounted) {\r\n                // 组件初始化的流程\r\n                // 调用render方法 （渲染页面的时候会进行取值操作，那么取值的时候会进行依赖收集 ， 收集对应的effect，稍后属性变化了会重新执行当前方法）\r\n                const subTree = instance.subTree = instance.render.call(proxy, proxy); // 渲染的时候会调用h方法\r\n\r\n                // 真正渲染组件 其实渲染的应该是subTree\r\n\r\n                patch(null, subTree, container); // 稍后渲染完subTree 会生成真实节点之后挂载到subTree\r\n                initialVNode.el = subTree.el\r\n                instance.isMounted = true;\r\n            } else {\r\n                // 组件更新的流程 。。。\r\n                // 我可以做 diff算法   比较前后的两颗树 \r\n\r\n                const prevTree = instance.subTree;\r\n                const nextTree = instance.render.call(proxy, proxy);\r\n                patch(prevTree, nextTree, container); // 比较两棵树\r\n            }\r\n        }\r\n        const effect = new ReactiveEffect(componentUpdateFn);\r\n        // 默认调用update方法 就会执行componentUpdateFn\r\n        const update = effect.run.bind(effect);\r\n        update();\r\n    }\r\n\r\n    const mountComponent = (initialVNode, container) => { // 组件的挂载流程\r\n        // 根据组件的虚拟节点 创造一个真实节点 ， 渲染到容器中\r\n        // 1.我们要给组件创造一个组件的实例 \r\n        const instance = initialVNode.component = createComponentInstance(initialVNode);\r\n        // 2. 需要给组件的实例进行赋值操作\r\n        setupComponent(instance); // 给实例赋予属性\r\n\r\n        // 3.调用render方法实现 组件的渲染逻辑。 如果依赖的状态发生变化 组件要重新渲染\r\n        // 数据和视图是双向绑定的 如果数据变化视图要更新 响应式原理 \r\n        // effect  data  effect 可以用在组件中，这样数据变化后可以自动重新的执行effect函数\r\n        setupRenderEffect(initialVNode, instance, container); // 渲染effect\r\n\r\n    }\r\n    const processComponent = (n1, n2, container) => {\r\n        if (n1 == null) {\r\n            // 组件的初始化\r\n            mountComponent(n2, container);\r\n        } else {\r\n            // 组件的更新\r\n        }\r\n    }\r\n\r\n    const mountChildren = (children, container) => {\r\n        // 如果是一个文本 可以直接   el.textContnt = 文本2\r\n        // ['文本1','文本2']   两个文本 需要 创建两个文本节点 塞入到我们的元素中\r\n\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = (children[i] = normalizeVNode(children[i]));\r\n            patch(null, child, container); // 如果是文本需要特殊处理\r\n        }\r\n    }\r\n\r\n    const mountElement = (vnode, container, anchor) => {\r\n        // vnode中的children  可能是字符串 或者是数组  对象数组  字符串数组\r\n\r\n        let { type, props, shapeFlag, children } = vnode; // 获取节点的类型 属性 儿子的形状 children\r\n\r\n        let el = vnode.el = hostCreateElement(type)\r\n\r\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n            hostSetElementText(el, children)\r\n        } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {  // 按位与\r\n            mountChildren(children, el);\r\n        }\r\n        // 处理属性\r\n        if (props) {\r\n            for (const key in props) {\r\n                hostPatchProp(el, key, null, props[key]); // 给元素添加属性\r\n            }\r\n        }\r\n        hostInsert(el, container, anchor);\r\n    }\r\n    const patchProps = (oldProps, newProps, el) => {\r\n        if (oldProps === newProps) return;\r\n\r\n        for (let key in newProps) {\r\n            const prev = oldProps[key];\r\n            const next = newProps[key]; // 获取新老属性\r\n            if (prev !== next) {\r\n                hostPatchProp(el, key, prev, next);\r\n            }\r\n        }\r\n        for (const key in oldProps) { // 老的有新的没有  移除老的\r\n            if (!(key in newProps)) {\r\n                hostPatchProp(el, key, oldProps[key], null);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    const unmountChildren = (children) => {\r\n        debugger;\r\n        for (let i = 0; i < children.length; i++) {\r\n            unmount(children[i])\r\n        }\r\n    }\r\n\r\n\r\n\r\n    const patchKeyedChildren = (c1, c2, container) => {\r\n        let e1 = c1.length - 1;\r\n        let e2 = c2.length - 1;\r\n        let i = 0; // 从头开始比较\r\n\r\n        // 1.sync from start 从头开始一个个孩子来比较 , 遇到不同的节点就停止了\r\n        while (i <= e1 && i <= e2) { // 如果i 和 新的列表或者老的列表指针重合说明就比较完毕了\r\n            const n1 = c1[i];\r\n            const n2 = c2[i];\r\n\r\n            if (isSameVNodeType(n1, n2)) { // 如果两个节点是相同节点 则需要递归比较孩子和自身的属性\r\n                patch(n1, n2, container)\r\n            } else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // sync from end\r\n        while (i <= e1 && i <= e2) { // 如果i 和 新的列表或者老的列表指针重合说明就比较完毕了\r\n            const n1 = c1[e1];\r\n            const n2 = c2[e2];\r\n            if (isSameVNodeType(n1, n2)) { // 如果两个节点是相同节点 则需要递归比较孩子和自身的属性\r\n                patch(n1, n2, container)\r\n            } else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--\r\n        }\r\n        console.log(i, e1, e2); // 确定好了 头部 和 尾部相同的节点 定位到除了头部和尾部的节点\r\n\r\n        // 3.common sequence + mount\r\n\r\n        if (i > e1) { // 看i和e1 之间的关系 如果i 大于 e1  说明有新增的元素\r\n            if (i <= e2) {  // i和 e2 之间的内容就是新增的\r\n\r\n                const nextPos = e2 + 1;\r\n                // 取e2 的下一个元素 如果下一个没有 则长度和当前c2长度相同  说明追加\r\n                // 取e2 的下一个元素 如果下一个有 说明要在头部追加 则取出下一个节点作为参照物\r\n                const anchor = nextPos < c2.length ? c2[nextPos].el : null;\r\n\r\n                // 参照物的目的 要计算是向前插入还是向后插入\r\n                while (i <= e2) {\r\n                    patch(null, c2[i], container, anchor); // 没有参照物 就是appendChild\r\n                    i++;\r\n                }\r\n            }\r\n\r\n            // 4.common sequence + unmount\r\n        } else if (i > e2) {   // 看一下 i 和 e2 的关系 如果 e2 比i小 说明 老的多新的少\r\n            while (i <= e1) {\r\n                // i 和 e1 之间的就是要删除的\r\n                unmount(c1[i]);\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // unknown sequence\r\n        const s1 = i;  // s1 -> e1 老的孩子列表\r\n        const s2 = i;  // s2 -> e2  新的孩子列表\r\n\r\n        // 根据新的节点 创造一个映射表 ， 用老的列表去里面找有没有，如果有则复用，没有就删除。 最后新的多余在追加\r\n\r\n        const keyToNewIndexMap = new Map(); // 这个目的是为了可以用老的来查看有没有新的\r\n        for (let i = s2; i <= e2; i++) {\r\n            const child = c2[i];\r\n            keyToNewIndexMap.set(child.key, i)\r\n        }\r\n\r\n        const toBepatched = e2 - s2 + 1; // 4\r\n        const newIndexToOldMapIndex = new Array(toBepatched).fill(0); // 最长递增子序列会用到这个列表  5 3 4 0\r\n\r\n\r\n\r\n\r\n        // 拿老的去新的中查找\r\n\r\n        // 找到一样的需要patch\r\n        for (let i = s1; i <= e1; i++) { // 新的索引映射到老的索引的映射表\r\n            const prevChild = c1[i]; // 拿到老的每一个节点\r\n            let newIndex = keyToNewIndexMap.get(prevChild.key);\r\n            if (newIndex == undefined) { // 删掉老的多余的\r\n                unmount(prevChild)\r\n            } else {\r\n                newIndexToOldMapIndex[newIndex - s2] = i + 1;// 保证填的肯定不是0 , 0意味着添加了一个元素\r\n\r\n                // 比较两个人的节点 \r\n                patch(prevChild, c2[newIndex], container); // 填表后 还要比对属性和儿子\r\n            }\r\n        }\r\n\r\n        // 在去移动需要移动的元素\r\n        let queue = getSequence(newIndexToOldMapIndex); // 求出队列   [1,2]  1 ,2 不用动\r\n\r\n        let j = queue.length - 1; // 拿到最长递增子序列的末尾索引\r\n        for (let i = toBepatched - 1; i >= 0; i--) {\r\n            let lastIndex = s2 + i; // h的索引\r\n            let lastChild = c2[lastIndex];\r\n            let anchor = lastIndex + 1 < c2.length ? c2[lastIndex + 1].el : null\r\n\r\n            if (newIndexToOldMapIndex[i] == 0) { // 等于0的时候还没有真实节点，需要创建真实节点在插入\r\n                patch(null, lastChild, container, anchor); // 创建一个h 插入到 f的前面\r\n            } else {\r\n                // 这里可以进行优化 问题出在可能有一些节点不需要移动，但是还是全部插入了一遍\r\n                // 性能消耗， 最长递增子序列 减少dom的插入操作 \r\n                if (i !== queue[j]) {\r\n                    // 3 2 1 0  倒叙插入 所以  i的值 就是  3 2 1 0\r\n                    hostInsert(lastChild.el, container, anchor); // 将列表倒序的插入\r\n                }else{\r\n                    j--; // 这里做了一个优化 表示元素不需要移动了\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const patchChildren = (n1, n2, el) => {\r\n        const c1 = n1 && n1.children;\r\n        const c2 = n2 && n2.children;\r\n        const prevShapeFlag = n1.shapeFlag;\r\n        const shapeFlag = n2.shapeFlag\r\n        // c1 和 c2 儿子有哪些类型 \r\n        // 1.之前是数组 ， 现在是文本   删除老的节点 ，用新的文本替换掉\r\n        // 2.之前是数组 ， 现在也是数组  比较两个儿子列表的差异  （* diff算法）\r\n        // 3.之前是文本， 现在是是空   直接删除老的即可\r\n\r\n        // 4.之前是文本  现在也是文本 直接更新文本\r\n        // 5.之前是文本 现在是数组  删除文本 新增儿子\r\n        // 6之前是空  现在是文本 \r\n        if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n            if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n                unmountChildren(c1); // 1.\r\n            }\r\n            if (c1 !== c2) { // 4.\r\n                hostSetElementText(el, c2);\r\n            }\r\n        } else {\r\n            // 现在是数组 \r\n            if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n                if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n                    patchKeyedChildren(c1, c2, el);\r\n                } else {\r\n                    // 之前是数组  空文本\r\n                    unmountChildren(c1);\r\n                }\r\n            } else {\r\n                // 之前是文本\r\n                if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\r\n                    hostSetElementText(el, '');\r\n                }\r\n                if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\r\n                    mountChildren(c2, el);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    const patchElement = (n1, n2) => {\r\n        let el = n2.el = n1.el; // 先比较元素 元素一致 则复用 \r\n        const oldProps = n1.props || {}; // 复用后比较属性\r\n        const newProps = n2.props || {};\r\n        patchProps(oldProps, newProps, el);\r\n\r\n        // 实现比较儿子  diff算法   我们的diff算法是同级别比较的\r\n\r\n        patchChildren(n1, n2, el); // 用新的儿子n2 和 老的儿子n1 来进行比对  比对后更新容器元素\r\n\r\n    }\r\n    const processElement = (n1, n2, container, anchor) => { // 组件对应的返回值的初始化\r\n        if (n1 == null) {\r\n            // 初始化\r\n            mountElement(n2, container, anchor);\r\n        } else {\r\n            // diff\r\n            patchElement(n1, n2); // 更新两个元素之间的差异\r\n        }\r\n\r\n    }\r\n    const processText = (n1, n2, container) => {\r\n        if (n1 === null) {\r\n            // 文本的初始化 \r\n            let textNode = hostCreateText(n2.children);\r\n            n2.el = textNode; // 要让虚拟节点和真实节点挂载上\r\n            hostInsert(textNode, container)\r\n        }\r\n    }\r\n    const unmount = (vnode) => {\r\n        hostRemove(vnode.el); // 删除真实节点即可\r\n    }\r\n    const patch = (n1, n2, container, anchor = null) => {\r\n        // 两个元素 完全没用关系 \r\n        if (n1 && !isSameVNodeType(n1, n2)) { // n1 有值 再看两个是否是相同节点\r\n            unmount(n1);\r\n            n1 = null;\r\n        }\r\n        // 如果前后元素不一致 需要删除老的元素 换成新的元素\r\n\r\n\r\n        if (n1 == n2) return;\r\n        const { shapeFlag, type } = n2; // createApp(组件)\r\n\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container);\r\n                break;\r\n\r\n            default:\r\n                if (shapeFlag & ShapeFlags.COMPONENT) {\r\n                    processComponent(n1, n2, container);\r\n                } else if (shapeFlag & ShapeFlags.ELEMENT) {\r\n                    processElement(n1, n2, container, anchor);\r\n                }\r\n        }\r\n    }\r\n    const render = (vnode, container) => { // 将虚拟节点 转化成真实节点渲染到容器中\r\n        // 后续还有更新 patch  包含初次渲染 还包含更新\r\n        patch(null, vnode, container);// 后续更新 prevNode nextNode container\r\n    }\r\n    // \r\n    return {\r\n        createApp: createAppAPI(render), // 创建一个api createApp\r\n        render\r\n    }\r\n}","export const nodeOps = {\r\n    insert: (child, parent, anchor = null) => { // 插入有追加的功能\r\n        parent.insertBefore(child, anchor); // parent.appendChild(child)\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: tag => document.createElement(tag),\r\n    createText: text => document.createTextNode(text),\r\n    setElementText: (el, text) => el.textContent = text,\r\n    setText: (node, text) => node.nodeValue = text,\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => document.querySelector(selector)\r\n}\r\n\r\n// runtime-dom 提供 节点操作的api -> 传递给 runtime-core ","\r\n\r\n// 需要比对属性 diff算法    属性比对前后值\r\nfunction patchClass(el, value) {\r\n    if (value == null) {\r\n        el.removeAttribute('class');\r\n    } else {\r\n        el.className = value;\r\n    }\r\n}\r\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style; // 操作的是样式\r\n    // 最新的肯定要全部加到元素上\r\n    for (let key in next) {\r\n        style[key] = next[key];\r\n    }\r\n    // 新的没有 但是老的有这个属性, 将老的移除掉\r\n    if (prev) {\r\n        for (let key in prev) {\r\n            if (next[key] == null) {\r\n                style[key] = null;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction createInvoker(value) {\r\n    const invoker = (e) => { // 每次事件触发调用的都是invoker \r\n        invoker.value(e)\r\n    }\r\n    invoker.value = value; // 存储这个变量, 后续想换绑 可以直接更新value值\r\n    return invoker\r\n}\r\nfunction patchEvent(el, key, nextValue) {\r\n    // vei  vue event invoker  缓存绑定的事件 \r\n    const invokers = el._vei || (el._vei = {}); // 在元素上绑定一个自定义属性 用来记录绑定的事件\r\n    let exisitingInvoker = invokers[key]; // 先看一下有没有绑定过这个事件\r\n    if (exisitingInvoker && nextValue) { // 换绑逻辑\r\n        exisitingInvoker.value = nextValue\r\n    } else {\r\n        const name = key.slice(2).toLowerCase(); // eventName\r\n        if (nextValue) {\r\n            const invoker = invokers[key] = createInvoker(nextValue); // 返回一个引用\r\n            el.addEventListener(name, invoker);  // 正规的时间 onClick =(e)=>{}\r\n        } else if (exisitingInvoker) {\r\n            // 如果下一个值没有 需要删除\r\n            el.removeEventListener(name, exisitingInvoker);\r\n            invokers[key] = undefined; // 解绑了\r\n        }\r\n        // else{\r\n        //     // 压根没有绑定过 事件就不需要删除了\r\n        // }\r\n    }\r\n}\r\nfunction patchAttr(el, key, value) {\r\n    if (value == null) {\r\n        el.removeAttribute(key)\r\n    } else {\r\n        el.setAttribute(key, value)\r\n    }\r\n}\r\nexport const patchProp = (el, key, prevValue, nextValue) => {\r\n    if (key === 'class') { // 类名 \r\n        patchClass(el, nextValue); // \r\n    } else if (key === 'style') { // 样式\r\n        patchStyle(el, prevValue, nextValue);\r\n    } else if (/^on[^a-z]/.test(key)) { // onXxx\r\n        // 如果有事件 addEventListener  如果没事件 应该用removeListener\r\n        patchEvent(el, key, nextValue);\r\n        // 绑定一个 换帮了一个  在换绑一个\r\n    } else {\r\n        // 其他属性 setAttribute\r\n        patchAttr(el, key, nextValue);\r\n    }\r\n}","\r\n// 需要涵盖我们的 dom操作的api 属性操作的api  ， 将这些api 传入到 我们的runtime-core中\r\n\r\n// runtime-core 在操作中不需要依赖于平台代码 （平台代码是被传入的）\r\n\r\n\r\n// 我们在渲染页面的时候 需要节点操作的一列方法\r\n\r\nimport { createRenderer } from '@vue/runtime-core';\r\nimport { nodeOps } from './nodeOps';\r\nimport { patchProp } from './patchProp';\r\n\r\nconst renderOptions = Object.assign(nodeOps, { patchProp }); // 包含所需要的所有api\r\n\r\n\r\n// 实现将renderOptions 传入到core中\r\n// runtime-dom  在这层 对我们浏览器的操作做了一些\r\n\r\nexport const createApp = (component, rootProps = null) => {\r\n    // 需要创建一个渲染器\r\n    const { createApp } = createRenderer(renderOptions); // runtime-core中的方法\r\n    let app = createApp(component, rootProps);\r\n    let { mount } = app; // 获取core中mount\r\n    app.mount = function (container) {  // 在重写mount\r\n        container = nodeOps.querySelector(container);\r\n        container.innerHTML = '';\r\n        mount(container); // 处理节点后传入到mount中\r\n    }\r\n    return app;\r\n}\r\n\r\nexport const createSSRApp = () =>{ \r\n\r\n}\r\n\r\n// ..\r\n\r\n// 12月12日班  周三周五晚 8-10  周日全天  直播课5个月 webpack react vue node\r\n\r\nexport * from '@vue/runtime-core'; // 导出这个模块中的所有代码  es6 模块规范"],"names":[],"mappings":"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"}